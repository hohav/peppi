// This file is auto-generated by `gen/scripts/frames`. Do not edit.

//! Immutable (fully-parsed) frame data, as Arrow arrays.
//!
//! This is what you get when you parse a game in one shot using [`crate::io::slippi::read`] or
//! [`crate::io::peppi::read`].
//!
//! These arrays can be shared, and cloning them is `O(1)`. See the
//! [arrow_array docs](https://docs.rs/arrow-array/latest/arrow_array/index.html) for more.

#![allow(unused_variables)]

mod peppi;
mod slippi;

use std::fmt;

use arrow::{
	array::{
		types::{Float32Type, Int32Type, Int8Type, UInt16Type, UInt32Type, UInt8Type},
		PrimitiveArray,
	},
	buffer::{NullBuffer, OffsetBuffer},
};

use crate::{
	frame::{self, transpose, Rollbacks},
	game::Port,
	io::slippi::Version,
};

/// Frame data for a single character (ICs are two characters).
#[derive(Debug)]
pub struct Data {
	pub pre: Pre,
	pub post: Post,
	pub validity: Option<NullBuffer>,
}

impl Data {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Data {
		transpose::Data {
			pre: self.pre.transpose_one(i, version),
			post: self.post.transpose_one(i, version),
		}
	}
}

/// Frame data for a single port.
#[derive(Debug)]
pub struct PortData {
	pub port: Port,
	pub leader: Data,
	/// The "backup" ICs character
	pub follower: Option<Data>,
}

impl PortData {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::PortData {
		transpose::PortData {
			port: self.port,
			leader: self.leader.transpose_one(i, version),
			follower: self.follower.as_ref().map(|f| f.transpose_one(i, version)),
		}
	}
}

/// All frame data for a single game, in struct-of-arrays format.
pub struct Frame {
	/// Frame IDs start at `-123` and increment each frame. May repeat in case of rollbacks
	pub id: PrimitiveArray<Int32Type>,
	/// Port-specific data
	pub ports: Vec<PortData>,
	/// Start-of-frame data
	pub start: Option<Start>,
	/// End-of-frame data
	pub end: Option<End>,
	/// Logically, each frame has its own array of items. But we represent all item data in a flat array, with this field indicating the start of each sub-array
	pub item_offset: Option<OffsetBuffer<i32>>,
	/// Item data
	pub item: Option<Item>,
}

impl Frame {
	pub fn len(&self) -> usize {
		self.id.len()
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Frame {
		transpose::Frame {
			id: self.id.values()[i],
			ports: self
				.ports
				.iter()
				.map(|p| p.transpose_one(i, version))
				.collect(),
			start: version
				.gte(2, 2)
				.then(|| self.start.as_ref().unwrap().transpose_one(i, version)),
			end: version
				.gte(3, 0)
				.then(|| self.end.as_ref().unwrap().transpose_one(i, version)),
			items: version.gte(3, 0).then(|| {
				let offsets = self.item_offset.as_ref().unwrap();
				let [start, end] = (*offsets)[i..i + 2] else {
					panic!("not enough item offsets: {}/{}", i, offsets.len());
				};
				(usize::try_from(start).unwrap()..usize::try_from(end).unwrap())
					.map(|i| self.item.as_ref().unwrap().transpose_one(i, version))
					.collect()
			}),
		}
	}

	/// Frames IDs may appear multiple times due to rollbacks. This fn lets you
	/// "dedupe" rollbacks, by returning `true` for all but one of each unique
	/// frame ID. The value returned at index `i` corresponds to `self.id[i]`.
	pub fn rollbacks(&self, keep: Rollbacks) -> Vec<bool> {
		use Rollbacks::*;
		match keep {
			ExceptFirst => self.rollbacks_(self.id.values().iter().cloned().enumerate()),
			ExceptLast => self.rollbacks_(self.id.values().iter().cloned().enumerate().rev()),
		}
	}

	fn rollbacks_<'a>(&self, ids: impl Iterator<Item = (usize, i32)>) -> Vec<bool> {
		let mut result = vec![false; self.len()];
		let unique_id_count = arrow::compute::kernels::aggregate::max(&self.id).map_or(0, |idx| {
			1 + usize::try_from(idx - frame::FIRST_INDEX).unwrap()
		});
		let mut seen = vec![false; unique_id_count];
		for (idx, id) in ids {
			let zero_based_id = usize::try_from(id - frame::FIRST_INDEX).unwrap();
			if !seen[zero_based_id] {
				seen[zero_based_id] = true;
				result[idx] = false;
			} else {
				result[idx] = true;
			}
		}
		result
	}
}

impl fmt::Debug for Frame {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> std::result::Result<(), fmt::Error> {
		write!(f, "Frame {{ len: {} }}", self.id.len())
	}
}

/// Information about the end of the game.
#[derive(Debug)]
pub struct End {
	/// *Added: v3.7* Index of the latest frame which is guaranteed not to happen again (rollback)
	pub latest_finalized_frame: Option<PrimitiveArray<Int32Type>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl End {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::End {
		transpose::End {
			latest_finalized_frame: self.latest_finalized_frame.as_ref().map(|x| x.value(i)),
		}
	}
}

/// An active item (includes projectiles).
#[derive(Debug)]
pub struct Item {
	/// Item type
	pub r#type: PrimitiveArray<UInt16Type>,
	/// Item’s action state
	pub state: PrimitiveArray<UInt8Type>,
	/// Direction item is facing
	pub direction: PrimitiveArray<Float32Type>,
	/// Item’s velocity
	pub velocity: Velocity,
	/// Item’s position
	pub position: Position,
	/// Amount of damage item has taken
	pub damage: PrimitiveArray<UInt16Type>,
	/// Frames remaining until item expires
	pub timer: PrimitiveArray<Float32Type>,
	/// Unique, serial ID per item spawned
	pub id: PrimitiveArray<UInt32Type>,
	/// *Added: v3.2* Miscellaneous item state
	pub misc: Option<ItemMisc>,
	/// *Added: v3.6* Port that owns the item (-1 when unowned)
	pub owner: Option<PrimitiveArray<Int8Type>>,
	/// *Added: v3.16* Inherited instance ID of the owner (0 when unowned)
	pub instance_id: Option<PrimitiveArray<UInt16Type>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Item {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Item {
		transpose::Item {
			r#type: self.r#type.value(i),
			state: self.state.value(i),
			direction: self.direction.value(i),
			velocity: self.velocity.transpose_one(i, version),
			position: self.position.transpose_one(i, version),
			damage: self.damage.value(i),
			timer: self.timer.value(i),
			id: self.id.value(i),
			misc: self.misc.as_ref().map(|x| x.transpose_one(i, version)),
			owner: self.owner.as_ref().map(|x| x.value(i)),
			instance_id: self.instance_id.as_ref().map(|x| x.value(i)),
		}
	}
}

/// Miscellaneous item state.
#[derive(Debug)]
pub struct ItemMisc(
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
);

impl ItemMisc {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::ItemMisc {
		transpose::ItemMisc(
			self.0.value(i),
			self.1.value(i),
			self.2.value(i),
			self.3.value(i),
		)
	}
}

/// 2D position.
#[derive(Debug)]
pub struct Position {
	pub x: PrimitiveArray<Float32Type>,
	pub y: PrimitiveArray<Float32Type>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Position {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Position {
		transpose::Position {
			x: self.x.value(i),
			y: self.y.value(i),
		}
	}
}

/// Post-frame update data, for making decisions about game states (such as computing stats).
///
/// Information is collected at the end of collision detection, which is the last consideration of the game engine.
#[derive(Debug)]
pub struct Post {
	/// In-game character (can only change for Zelda/Sheik)
	pub character: PrimitiveArray<UInt8Type>,
	/// Character’s action state
	pub state: PrimitiveArray<UInt16Type>,
	/// Character’s position
	pub position: Position,
	/// Direction the character is facing
	pub direction: PrimitiveArray<Float32Type>,
	/// Damage taken (percent)
	pub percent: PrimitiveArray<Float32Type>,
	/// Size/health of shield
	pub shield: PrimitiveArray<Float32Type>,
	/// Last attack ID that this character landed
	pub last_attack_landed: PrimitiveArray<UInt8Type>,
	/// Combo count (as defined by the game)
	pub combo_count: PrimitiveArray<UInt8Type>,
	/// Port that last hit this player. Bugged in Melee: will be set to `6` in certain situations
	pub last_hit_by: PrimitiveArray<UInt8Type>,
	/// Number of stocks remaining
	pub stocks: PrimitiveArray<UInt8Type>,
	/// *Added: v0.2* Number of frames action state has been active. Can have a fractional component
	pub state_age: Option<PrimitiveArray<Float32Type>>,
	/// *Added: v2.0* State flags
	pub state_flags: Option<StateFlags>,
	/// *Added: v2.0* Used for different things. While in hitstun, contains hitstun frames remaining
	pub misc_as: Option<PrimitiveArray<Float32Type>>,
	/// *Added: v2.0* Is the character airborne?
	pub airborne: Option<PrimitiveArray<UInt8Type>>,
	/// *Added: v2.0* Ground ID the character last touched
	pub ground: Option<PrimitiveArray<UInt16Type>>,
	/// *Added: v2.0* Number of jumps remaining
	pub jumps: Option<PrimitiveArray<UInt8Type>>,
	/// *Added: v2.0* L-cancel status (0 = none, 1 = successful, 2 = unsuccessful)
	pub l_cancel: Option<PrimitiveArray<UInt8Type>>,
	/// *Added: v2.1* Hurtbox state (0 = vulnerable, 1 = invulnerable, 2 = intangible)
	pub hurtbox_state: Option<PrimitiveArray<UInt8Type>>,
	/// *Added: v3.5* Self-induced and knockback velocities
	pub velocities: Option<Velocities>,
	/// *Added: v3.8* Hitlag frames remaining
	pub hitlag: Option<PrimitiveArray<Float32Type>>,
	/// *Added: v3.11* Animation the character is in
	pub animation_index: Option<PrimitiveArray<UInt32Type>>,
	/// *Added: v3.16* Instance ID of the player/item that last hit this player
	pub last_hit_by_instance: Option<PrimitiveArray<UInt16Type>>,
	/// *Added: v3.16* Unique, serial ID for each new action state across all characters. Resets to 0 on death
	pub instance_id: Option<PrimitiveArray<UInt16Type>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Post {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Post {
		transpose::Post {
			character: self.character.value(i),
			state: self.state.value(i),
			position: self.position.transpose_one(i, version),
			direction: self.direction.value(i),
			percent: self.percent.value(i),
			shield: self.shield.value(i),
			last_attack_landed: self.last_attack_landed.value(i),
			combo_count: self.combo_count.value(i),
			last_hit_by: self.last_hit_by.value(i),
			stocks: self.stocks.value(i),
			state_age: self.state_age.as_ref().map(|x| x.value(i)),
			state_flags: self
				.state_flags
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			misc_as: self.misc_as.as_ref().map(|x| x.value(i)),
			airborne: self.airborne.as_ref().map(|x| x.value(i)),
			ground: self.ground.as_ref().map(|x| x.value(i)),
			jumps: self.jumps.as_ref().map(|x| x.value(i)),
			l_cancel: self.l_cancel.as_ref().map(|x| x.value(i)),
			hurtbox_state: self.hurtbox_state.as_ref().map(|x| x.value(i)),
			velocities: self
				.velocities
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			hitlag: self.hitlag.as_ref().map(|x| x.value(i)),
			animation_index: self.animation_index.as_ref().map(|x| x.value(i)),
			last_hit_by_instance: self.last_hit_by_instance.as_ref().map(|x| x.value(i)),
			instance_id: self.instance_id.as_ref().map(|x| x.value(i)),
		}
	}
}

/// Pre-frame update data, required to reconstruct a replay.
///
/// Information is collected right before controller inputs are used to figure out the character’s next action.
#[derive(Debug)]
pub struct Pre {
	/// Random seed
	pub random_seed: PrimitiveArray<UInt32Type>,
	/// Character’s action state
	pub state: PrimitiveArray<UInt16Type>,
	/// Character’s position
	pub position: Position,
	/// Direction the character is facing
	pub direction: PrimitiveArray<Float32Type>,
	/// Processed analog joystick position
	pub joystick: Position,
	/// Processed analog c-stick position
	pub cstick: Position,
	/// Processed analog trigger position
	pub triggers: PrimitiveArray<Float32Type>,
	/// Processed button-state bitmask
	pub buttons: PrimitiveArray<UInt32Type>,
	/// Physical button-state bitmask
	pub buttons_physical: PrimitiveArray<UInt16Type>,
	/// Physical analog trigger positions (useful for IPM)
	pub triggers_physical: TriggersPhysical,
	/// *Added: v1.2* Raw joystick x-position
	pub raw_analog_x: Option<PrimitiveArray<Int8Type>>,
	/// *Added: v1.4* Damage taken (percent)
	pub percent: Option<PrimitiveArray<Float32Type>>,
	/// *Added: v3.15* Raw joystick y-position
	pub raw_analog_y: Option<PrimitiveArray<Int8Type>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Pre {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Pre {
		transpose::Pre {
			random_seed: self.random_seed.value(i),
			state: self.state.value(i),
			position: self.position.transpose_one(i, version),
			direction: self.direction.value(i),
			joystick: self.joystick.transpose_one(i, version),
			cstick: self.cstick.transpose_one(i, version),
			triggers: self.triggers.value(i),
			buttons: self.buttons.value(i),
			buttons_physical: self.buttons_physical.value(i),
			triggers_physical: self.triggers_physical.transpose_one(i, version),
			raw_analog_x: self.raw_analog_x.as_ref().map(|x| x.value(i)),
			percent: self.percent.as_ref().map(|x| x.value(i)),
			raw_analog_y: self.raw_analog_y.as_ref().map(|x| x.value(i)),
		}
	}
}

/// Initialization data such as game mode, settings, characters & stage.
#[derive(Debug)]
pub struct Start {
	/// Random seed
	pub random_seed: PrimitiveArray<UInt32Type>,
	/// *Added: v3.10* Scene frame counter. Starts at 0, and increments every frame (even when paused)
	pub scene_frame_counter: Option<PrimitiveArray<UInt32Type>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Start {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Start {
		transpose::Start {
			random_seed: self.random_seed.value(i),
			scene_frame_counter: self.scene_frame_counter.as_ref().map(|x| x.value(i)),
		}
	}
}

/// Miscellaneous state flags.
#[derive(Debug)]
pub struct StateFlags(
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
	pub PrimitiveArray<UInt8Type>,
);

impl StateFlags {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::StateFlags {
		transpose::StateFlags(
			self.0.value(i),
			self.1.value(i),
			self.2.value(i),
			self.3.value(i),
			self.4.value(i),
		)
	}
}

/// Trigger state.
#[derive(Debug)]
pub struct TriggersPhysical {
	pub l: PrimitiveArray<Float32Type>,
	pub r: PrimitiveArray<Float32Type>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl TriggersPhysical {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::TriggersPhysical {
		transpose::TriggersPhysical {
			l: self.l.value(i),
			r: self.r.value(i),
		}
	}
}

/// Self-induced and knockback velocities.
#[derive(Debug)]
pub struct Velocities {
	/// Self-induced x-velocity (airborne)
	pub self_x_air: PrimitiveArray<Float32Type>,
	/// Self-induced y-velocity
	pub self_y: PrimitiveArray<Float32Type>,
	/// Knockback-induced x-velocity
	pub knockback_x: PrimitiveArray<Float32Type>,
	/// Knockback-induced y-velocity
	pub knockback_y: PrimitiveArray<Float32Type>,
	/// Self-induced x-velocity (grounded)
	pub self_x_ground: PrimitiveArray<Float32Type>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Velocities {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Velocities {
		transpose::Velocities {
			self_x_air: self.self_x_air.value(i),
			self_y: self.self_y.value(i),
			knockback_x: self.knockback_x.value(i),
			knockback_y: self.knockback_y.value(i),
			self_x_ground: self.self_x_ground.value(i),
		}
	}
}

/// 2D velocity.
#[derive(Debug)]
pub struct Velocity {
	pub x: PrimitiveArray<Float32Type>,
	pub y: PrimitiveArray<Float32Type>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<NullBuffer>,
}

impl Velocity {
	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Velocity {
		transpose::Velocity {
			x: self.x.value(i),
			y: self.y.value(i),
		}
	}
}
