// This file is auto-generated by `gen/scripts/frames`. Do not edit.

#![allow(unused_variables)]

use arrow2::{
	array::{Array, ListArray, PrimitiveArray, StructArray},
	datatypes::{DataType, Field},
	offset::OffsetsBuffer,
};

use crate::{
	frame::{
		immutable::{Data, Frame, PortData},
		PortOccupancy,
	},
	game::{Port, NUM_PORTS},
	io::slippi::Version,
};

trait StructArrayConvertible {
	fn data_type(version: Version) -> DataType;
	fn into_struct_array(self, version: Version) -> StructArray;
	fn from_struct_array(array: StructArray, version: Version) -> Self;
}

impl Data {
	fn data_type(version: Version) -> DataType {
		DataType::Struct(vec![
			Field::new("pre", Pre::data_type(version).clone(), false),
			Field::new("post", Post::data_type(version).clone(), false),
		])
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let values = vec![
			self.pre.into_struct_array(version).boxed(),
			self.post.into_struct_array(version).boxed(),
		];
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			pre: Pre::from_struct_array(
				values[0]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			post: Post::from_struct_array(
				values[1]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			validity: validity,
		}
	}
}

impl PortData {
	fn data_type(version: Version, port: PortOccupancy) -> DataType {
		let mut fields = vec![Field::new(
			"leader",
			Data::data_type(version).clone(),
			false,
		)];
		if port.follower {
			fields.push(Field::new(
				"follower",
				Data::data_type(version).clone(),
				false,
			));
		}
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version, port: PortOccupancy) -> StructArray {
		let mut values = vec![self.leader.into_struct_array(version).boxed()];
		if let Some(follower) = self.follower {
			values.push(follower.into_struct_array(version).boxed());
		}
		StructArray::new(Self::data_type(version, port), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version, port: Port) -> Self {
		let (fields, values, _) = array.into_data();
		assert_eq!("leader", fields[0].name);
		fields.get(1).map(|f| assert_eq!("follower", f.name));
		Self {
			port: port,
			leader: Data::from_struct_array(
				values[0]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			follower: values.get(1).map(|x| {
				Data::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
		}
	}
}

impl Frame {
	fn port_data_type(version: Version, ports: &[PortOccupancy]) -> DataType {
		DataType::Struct(
			ports
				.iter()
				.map(|p| {
					Field::new(
						format!("{}", p.port),
						PortData::data_type(version, *p).clone(),
						false,
					)
				})
				.collect(),
		)
	}

	fn item_data_type(version: Version) -> DataType {
		DataType::List(Box::new(Field::new(
			"item",
			Item::data_type(version),
			false,
		)))
	}

	fn fod_platform_data_type(version: Version) -> DataType {
		DataType::List(Box::new(Field::new(
			"fod_platform",
			FodPlatform::data_type(version),
			false,
		)))
	}

	fn dreamland_whispy_data_type(version: Version) -> DataType {
		DataType::List(Box::new(Field::new(
			"dreamland_whispy",
			DreamlandWhispy::data_type(version),
			false,
		)))
	}

	fn stadium_transformation_data_type(version: Version) -> DataType {
		DataType::List(Box::new(Field::new(
			"stadium_transformation",
			StadiumTransformation::data_type(version),
			false,
		)))
	}

	fn data_type(version: Version, ports: &[PortOccupancy]) -> DataType {
		let mut fields = vec![
			Field::new("id", DataType::Int32, false),
			Field::new("ports", Self::port_data_type(version, ports).clone(), false),
		];
		if version.gte(2, 2) {
			fields.push(Field::new(
				"start",
				Start::data_type(version).clone(),
				false,
			));
			if version.gte(3, 0) {
				fields.push(Field::new("end", End::data_type(version).clone(), false));
				fields.push(Field::new(
					"item",
					Self::item_data_type(version).clone(),
					false,
				));
				if version.gte(3, 18) {
					fields.push(Field::new(
						"fod_platform",
						Self::fod_platform_data_type(version).clone(),
						false,
					));
					fields.push(Field::new(
						"dreamland_whispy",
						Self::dreamland_whispy_data_type(version).clone(),
						false,
					));
					fields.push(Field::new(
						"stadium_transformation",
						Self::stadium_transformation_data_type(version).clone(),
						false,
					));
				}
			}
		}
		DataType::Struct(fields)
	}

	pub fn into_struct_array(self, version: Version, ports: &[PortOccupancy]) -> StructArray {
		let values: Vec<_> = std::iter::zip(ports, self.ports)
			.map(|(occupancy, data)| data.into_struct_array(version, *occupancy).boxed())
			.collect();

		let mut arrays = vec![
			self.id.boxed(),
			StructArray::new(Self::port_data_type(version, ports), values, None).boxed(),
		];

		if version.gte(2, 2) {
			arrays.push(self.start.unwrap().into_struct_array(version).boxed());
			if version.gte(3, 0) {
				arrays.push(self.end.unwrap().into_struct_array(version).boxed());
				let item_values = self.item.unwrap().into_struct_array(version).boxed();
				arrays.push(
					ListArray::new(
						Self::item_data_type(version),
						self.item_offset.unwrap(),
						item_values,
						None,
					)
					.boxed(),
				);
				if version.gte(3, 18) {
					let fod_platform_values = self
						.fod_platform
						.unwrap()
						.into_struct_array(version)
						.boxed();
					arrays.push(
						ListArray::new(
							Self::fod_platform_data_type(version),
							self.fod_platform_offset.unwrap(),
							fod_platform_values,
							None,
						)
						.boxed(),
					);
					let dreamland_whispy_values = self
						.dreamland_whispy
						.unwrap()
						.into_struct_array(version)
						.boxed();
					arrays.push(
						ListArray::new(
							Self::dreamland_whispy_data_type(version),
							self.dreamland_whispy_offset.unwrap(),
							dreamland_whispy_values,
							None,
						)
						.boxed(),
					);
					let stadium_transformation_values = self
						.stadium_transformation
						.unwrap()
						.into_struct_array(version)
						.boxed();
					arrays.push(
						ListArray::new(
							Self::stadium_transformation_data_type(version),
							self.stadium_transformation_offset.unwrap(),
							stadium_transformation_values,
							None,
						)
						.boxed(),
					);
				}
			}
		}

		StructArray::new(Self::data_type(version, ports), arrays, None)
	}

	fn port_data_from_struct_array(array: StructArray, version: Version) -> Vec<PortData> {
		let (fields, values, _) = array.into_data();
		let mut ports = vec![];
		for i in 0..NUM_PORTS {
			if let Some(a) = values.get(i as usize) {
				ports.push(PortData::from_struct_array(
					a.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
					Port::parse(&fields[i as usize].name).unwrap(),
				));
			}
		}
		ports
	}

	fn values_and_offsets<T: StructArrayConvertible>(
		arr: &Box<dyn Array>,
		version: Version,
	) -> (Option<T>, Option<OffsetsBuffer<i32>>) {
		let arrays = arr
			.as_any()
			.downcast_ref::<ListArray<i32>>()
			.unwrap()
			.clone();
		let offsets = arrays.offsets().clone();
		let values = T::from_struct_array(
			arrays
				.values()
				.as_any()
				.downcast_ref::<StructArray>()
				.unwrap()
				.clone(),
			version,
		);
		(Some(values), Some(offsets))
	}

	pub fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (fields, values, _) = array.into_data();
		assert_eq!("id", fields[0].name);
		assert_eq!("ports", fields[1].name);
		if version.gte(2, 2) {
			assert_eq!("start", fields[2].name);
			if version.gte(3, 0) {
				assert_eq!("end", fields[3].name);
				assert_eq!("item", fields[4].name);
				if version.gte(3, 18) {
					assert_eq!("fod_platform", fields[5].name);
					assert_eq!("dreamland_whispy", fields[6].name);
					assert_eq!("stadium_transformation", fields[7].name);
				}
			}
		}

		let (item, item_offset) = values
			.get(4)
			.map_or((None, None), |arr| Frame::values_and_offsets(arr, version));
		let (fod_platform, fod_platform_offset) = values
			.get(5)
			.map_or((None, None), |arr| Frame::values_and_offsets(arr, version));
		let (dreamland_whispy, dreamland_whispy_offset) = values
			.get(6)
			.map_or((None, None), |arr| Frame::values_and_offsets(arr, version));
		let (stadium_transformation, stadium_transformation_offset) = values
			.get(7)
			.map_or((None, None), |arr| Frame::values_and_offsets(arr, version));

		Self {
			id: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<i32>>()
				.unwrap()
				.clone(),
			ports: Self::port_data_from_struct_array(
				values[1]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			start: values.get(2).map(|v| {
				Start::from_struct_array(
					v.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			end: values.get(3).map(|v| {
				End::from_struct_array(
					v.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			item,
			item_offset,
			fod_platform,
			fod_platform_offset,
			dreamland_whispy,
			dreamland_whispy_offset,
			stadium_transformation,
			stadium_transformation_offset,
		}
	}
}

use crate::frame::immutable::DreamlandWhispy;

impl StructArrayConvertible for DreamlandWhispy {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("direction", DataType::UInt8, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.direction.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			direction: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}

use crate::frame::immutable::End;

impl StructArrayConvertible for End {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			if version.gte(3, 7) {
				fields.push(Field::new("latest_finalized_frame", DataType::Int32, false))
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		if version.gte(3, 7) {
			values.push(self.latest_finalized_frame.unwrap().boxed())
		};
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			latest_finalized_frame: values.get(0).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i32>>()
					.unwrap()
					.clone()
			}),
			validity: validity,
		}
	}
}

use crate::frame::immutable::FodPlatform;

impl StructArrayConvertible for FodPlatform {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("platform", DataType::UInt8, false));
			fields.push(Field::new("height", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.platform.boxed());
		values.push(self.height.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			platform: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			height: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}

use crate::frame::immutable::Item;

impl StructArrayConvertible for Item {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("type", DataType::UInt16, false));
			fields.push(Field::new("state", DataType::UInt8, false));
			fields.push(Field::new("direction", DataType::Float32, false));
			fields.push(Field::new("velocity", Velocity::data_type(version), false));
			fields.push(Field::new("position", Position::data_type(version), false));
			fields.push(Field::new("damage", DataType::UInt16, false));
			fields.push(Field::new("timer", DataType::Float32, false));
			fields.push(Field::new("id", DataType::UInt32, false));
			if version.gte(3, 2) {
				fields.push(Field::new("misc", ItemMisc::data_type(version), false));
				if version.gte(3, 6) {
					fields.push(Field::new("owner", DataType::Int8, false));
					if version.gte(3, 16) {
						fields.push(Field::new("instance_id", DataType::UInt16, false))
					}
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.r#type.boxed());
		values.push(self.state.boxed());
		values.push(self.direction.boxed());
		values.push(self.velocity.into_struct_array(version).boxed());
		values.push(self.position.into_struct_array(version).boxed());
		values.push(self.damage.boxed());
		values.push(self.timer.boxed());
		values.push(self.id.boxed());
		if version.gte(3, 2) {
			values.push(self.misc.unwrap().into_struct_array(version).boxed());
			if version.gte(3, 6) {
				values.push(self.owner.unwrap().boxed());
				if version.gte(3, 16) {
					values.push(self.instance_id.unwrap().boxed())
				}
			}
		};
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			r#type: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			state: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			direction: values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			velocity: Velocity::from_struct_array(
				values[3]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			position: Position::from_struct_array(
				values[4]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			damage: values[5]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			timer: values[6]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			id: values[7]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			misc: values.get(8).map(|x| {
				ItemMisc::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			owner: values.get(9).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
			instance_id: values.get(10).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u16>>()
					.unwrap()
					.clone()
			}),
			validity: validity,
		}
	}
}

use crate::frame::immutable::ItemMisc;

impl StructArrayConvertible for ItemMisc {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("0", DataType::UInt8, false));
			fields.push(Field::new("1", DataType::UInt8, false));
			fields.push(Field::new("2", DataType::UInt8, false));
			fields.push(Field::new("3", DataType::UInt8, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.0.boxed());
		values.push(self.1.boxed());
		values.push(self.2.boxed());
		values.push(self.3.boxed());
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self(
			values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
		)
	}
}

use crate::frame::immutable::Position;

impl StructArrayConvertible for Position {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("x", DataType::Float32, false));
			fields.push(Field::new("y", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.x.boxed());
		values.push(self.y.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			x: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			y: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}

use crate::frame::immutable::Post;

impl StructArrayConvertible for Post {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("character", DataType::UInt8, false));
			fields.push(Field::new("state", DataType::UInt16, false));
			fields.push(Field::new("position", Position::data_type(version), false));
			fields.push(Field::new("direction", DataType::Float32, false));
			fields.push(Field::new("percent", DataType::Float32, false));
			fields.push(Field::new("shield", DataType::Float32, false));
			fields.push(Field::new("last_attack_landed", DataType::UInt8, false));
			fields.push(Field::new("combo_count", DataType::UInt8, false));
			fields.push(Field::new("last_hit_by", DataType::UInt8, false));
			fields.push(Field::new("stocks", DataType::UInt8, false));
			if version.gte(0, 2) {
				fields.push(Field::new("state_age", DataType::Float32, false));
				if version.gte(2, 0) {
					fields.push(Field::new(
						"state_flags",
						StateFlags::data_type(version),
						false,
					));
					fields.push(Field::new("misc_as", DataType::Float32, false));
					fields.push(Field::new("airborne", DataType::UInt8, false));
					fields.push(Field::new("ground", DataType::UInt16, false));
					fields.push(Field::new("jumps", DataType::UInt8, false));
					fields.push(Field::new("l_cancel", DataType::UInt8, false));
					if version.gte(2, 1) {
						fields.push(Field::new("hurtbox_state", DataType::UInt8, false));
						if version.gte(3, 5) {
							fields.push(Field::new(
								"velocities",
								Velocities::data_type(version),
								false,
							));
							if version.gte(3, 8) {
								fields.push(Field::new("hitlag", DataType::Float32, false));
								if version.gte(3, 11) {
									fields.push(Field::new(
										"animation_index",
										DataType::UInt32,
										false,
									));
									if version.gte(3, 16) {
										fields.push(Field::new(
											"last_hit_by_instance",
											DataType::UInt16,
											false,
										));
										fields.push(Field::new(
											"instance_id",
											DataType::UInt16,
											false,
										))
									}
								}
							}
						}
					}
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.character.boxed());
		values.push(self.state.boxed());
		values.push(self.position.into_struct_array(version).boxed());
		values.push(self.direction.boxed());
		values.push(self.percent.boxed());
		values.push(self.shield.boxed());
		values.push(self.last_attack_landed.boxed());
		values.push(self.combo_count.boxed());
		values.push(self.last_hit_by.boxed());
		values.push(self.stocks.boxed());
		if version.gte(0, 2) {
			values.push(self.state_age.unwrap().boxed());
			if version.gte(2, 0) {
				values.push(self.state_flags.unwrap().into_struct_array(version).boxed());
				values.push(self.misc_as.unwrap().boxed());
				values.push(self.airborne.unwrap().boxed());
				values.push(self.ground.unwrap().boxed());
				values.push(self.jumps.unwrap().boxed());
				values.push(self.l_cancel.unwrap().boxed());
				if version.gte(2, 1) {
					values.push(self.hurtbox_state.unwrap().boxed());
					if version.gte(3, 5) {
						values.push(self.velocities.unwrap().into_struct_array(version).boxed());
						if version.gte(3, 8) {
							values.push(self.hitlag.unwrap().boxed());
							if version.gte(3, 11) {
								values.push(self.animation_index.unwrap().boxed());
								if version.gte(3, 16) {
									values.push(self.last_hit_by_instance.unwrap().boxed());
									values.push(self.instance_id.unwrap().boxed())
								}
							}
						}
					}
				}
			}
		};
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			character: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			state: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			position: Position::from_struct_array(
				values[2]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			direction: values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			percent: values[4]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			shield: values[5]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			last_attack_landed: values[6]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			combo_count: values[7]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			last_hit_by: values[8]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			stocks: values[9]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			state_age: values.get(10).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			state_flags: values.get(11).map(|x| {
				StateFlags::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			misc_as: values.get(12).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			airborne: values.get(13).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			ground: values.get(14).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u16>>()
					.unwrap()
					.clone()
			}),
			jumps: values.get(15).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			l_cancel: values.get(16).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			hurtbox_state: values.get(17).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			velocities: values.get(18).map(|x| {
				Velocities::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			hitlag: values.get(19).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			animation_index: values.get(20).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u32>>()
					.unwrap()
					.clone()
			}),
			last_hit_by_instance: values.get(21).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u16>>()
					.unwrap()
					.clone()
			}),
			instance_id: values.get(22).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u16>>()
					.unwrap()
					.clone()
			}),
			validity: validity,
		}
	}
}

use crate::frame::immutable::Pre;

impl StructArrayConvertible for Pre {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("random_seed", DataType::UInt32, false));
			fields.push(Field::new("state", DataType::UInt16, false));
			fields.push(Field::new("position", Position::data_type(version), false));
			fields.push(Field::new("direction", DataType::Float32, false));
			fields.push(Field::new("joystick", Position::data_type(version), false));
			fields.push(Field::new("cstick", Position::data_type(version), false));
			fields.push(Field::new("triggers", DataType::Float32, false));
			fields.push(Field::new("buttons", DataType::UInt32, false));
			fields.push(Field::new("buttons_physical", DataType::UInt16, false));
			fields.push(Field::new(
				"triggers_physical",
				TriggersPhysical::data_type(version),
				false,
			));
			if version.gte(1, 2) {
				fields.push(Field::new("raw_analog_x", DataType::Int8, false));
				if version.gte(1, 4) {
					fields.push(Field::new("percent", DataType::Float32, false));
					if version.gte(3, 15) {
						fields.push(Field::new("raw_analog_y", DataType::Int8, false));
						if version.gte(3, 17) {
							fields.push(Field::new("raw_analog_cstick_x", DataType::Int8, false));
							fields.push(Field::new("raw_analog_cstick_y", DataType::Int8, false))
						}
					}
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.random_seed.boxed());
		values.push(self.state.boxed());
		values.push(self.position.into_struct_array(version).boxed());
		values.push(self.direction.boxed());
		values.push(self.joystick.into_struct_array(version).boxed());
		values.push(self.cstick.into_struct_array(version).boxed());
		values.push(self.triggers.boxed());
		values.push(self.buttons.boxed());
		values.push(self.buttons_physical.boxed());
		values.push(self.triggers_physical.into_struct_array(version).boxed());
		if version.gte(1, 2) {
			values.push(self.raw_analog_x.unwrap().boxed());
			if version.gte(1, 4) {
				values.push(self.percent.unwrap().boxed());
				if version.gte(3, 15) {
					values.push(self.raw_analog_y.unwrap().boxed());
					if version.gte(3, 17) {
						values.push(self.raw_analog_cstick_x.unwrap().boxed());
						values.push(self.raw_analog_cstick_y.unwrap().boxed())
					}
				}
			}
		};
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			random_seed: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			state: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			position: Position::from_struct_array(
				values[2]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			direction: values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			joystick: Position::from_struct_array(
				values[4]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			cstick: Position::from_struct_array(
				values[5]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			triggers: values[6]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			buttons: values[7]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			buttons_physical: values[8]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			triggers_physical: TriggersPhysical::from_struct_array(
				values[9]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			raw_analog_x: values.get(10).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
			percent: values.get(11).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			raw_analog_y: values.get(12).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
			raw_analog_cstick_x: values.get(13).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
			raw_analog_cstick_y: values.get(14).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
			validity: validity,
		}
	}
}

use crate::frame::immutable::StadiumTransformation;

impl StructArrayConvertible for StadiumTransformation {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("event", DataType::UInt16, false));
			fields.push(Field::new("type", DataType::UInt16, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.event.boxed());
		values.push(self.r#type.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			event: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			r#type: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}

use crate::frame::immutable::Start;

impl StructArrayConvertible for Start {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("random_seed", DataType::UInt32, false));
			if version.gte(3, 10) {
				fields.push(Field::new("scene_frame_counter", DataType::UInt32, false))
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.random_seed.boxed());
		if version.gte(3, 10) {
			values.push(self.scene_frame_counter.unwrap().boxed())
		};
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			random_seed: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			scene_frame_counter: values.get(1).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u32>>()
					.unwrap()
					.clone()
			}),
			validity: validity,
		}
	}
}

use crate::frame::immutable::StateFlags;

impl StructArrayConvertible for StateFlags {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("0", DataType::UInt8, false));
			fields.push(Field::new("1", DataType::UInt8, false));
			fields.push(Field::new("2", DataType::UInt8, false));
			fields.push(Field::new("3", DataType::UInt8, false));
			fields.push(Field::new("4", DataType::UInt8, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.0.boxed());
		values.push(self.1.boxed());
		values.push(self.2.boxed());
		values.push(self.3.boxed());
		values.push(self.4.boxed());
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self(
			values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[4]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
		)
	}
}

use crate::frame::immutable::TriggersPhysical;

impl StructArrayConvertible for TriggersPhysical {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("l", DataType::Float32, false));
			fields.push(Field::new("r", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.l.boxed());
		values.push(self.r.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			l: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			r: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}

use crate::frame::immutable::Velocities;

impl StructArrayConvertible for Velocities {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("self_x_air", DataType::Float32, false));
			fields.push(Field::new("self_y", DataType::Float32, false));
			fields.push(Field::new("knockback_x", DataType::Float32, false));
			fields.push(Field::new("knockback_y", DataType::Float32, false));
			fields.push(Field::new("self_x_ground", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.self_x_air.boxed());
		values.push(self.self_y.boxed());
		values.push(self.knockback_x.boxed());
		values.push(self.knockback_y.boxed());
		values.push(self.self_x_ground.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			self_x_air: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			self_y: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			knockback_x: values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			knockback_y: values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			self_x_ground: values[4]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}

use crate::frame::immutable::Velocity;

impl StructArrayConvertible for Velocity {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("x", DataType::Float32, false));
			fields.push(Field::new("y", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		values.push(self.x.boxed());
		values.push(self.y.boxed());
		StructArray::new(Self::data_type(version), values, self.validity)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, validity) = array.into_data();
		Self {
			x: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			y: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			validity: validity,
		}
	}
}
