// This file is auto-generated by `gen/scripts/frames`. Do not edit.

//! Mutable (in-progress) frame data.
//!
//! You’ll only encounter mutable frame data if you’re parsing live games.

#![allow(unused_variables)]
#![allow(dead_code)]

use arrow2::{
	array::{MutableArray, MutablePrimitiveArray},
	bitmap::MutableBitmap,
	offset::Offsets,
};

use byteorder::ReadBytesExt;
use std::io::Result;

use crate::{
	frame::{transpose, PortOccupancy},
	game::Port,
	io::slippi::Version,
};

type BE = byteorder::BigEndian;

/// Frame data for a single character (ICs are two characters).
pub struct Data {
	pub pre: Pre,
	pub post: Post,
	pub validity: Option<MutableBitmap>,
}

impl Data {
	pub fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			pre: Pre::with_capacity(capacity, version),
			post: Post::with_capacity(capacity, version),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.pre.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.pre.push_null(version);
		self.post.push_null(version);
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Data {
		transpose::Data {
			pre: self.pre.transpose_one(i, version),
			post: self.post.transpose_one(i, version),
		}
	}
}

/// Frame data for a single port.
pub struct PortData {
	pub port: Port,
	pub leader: Data,
	/// The "backup" ICs character
	pub follower: Option<Data>,
}

impl PortData {
	pub fn with_capacity(capacity: usize, version: Version, port: PortOccupancy) -> Self {
		Self {
			port: port.port,
			leader: Data::with_capacity(capacity, version),
			follower: match port.follower {
				true => Some(Data::with_capacity(capacity, version)),
				_ => None,
			},
		}
	}

	pub fn len(&self) -> usize {
		self.leader.len()
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::PortData {
		transpose::PortData {
			port: self.port,
			leader: self.leader.transpose_one(i, version),
			follower: self.follower.as_ref().map(|f| f.transpose_one(i, version)),
		}
	}
}

/// All frame data for a single game, in struct-of-arrays format.
pub struct Frame {
	/// Frame IDs start at `-123` and increment each frame. May repeat in case of rollbacks
	pub id: MutablePrimitiveArray<i32>,
	/// Port-specific data
	pub ports: Vec<PortData>,
	/// Start-of-frame data
	pub start: Option<Start>,
	/// End-of-frame data
	pub end: Option<End>,

	/// Item data
	pub item: Option<Item>,
	/// Logically, each frame has its own array of items. But we represent all item data in a flat array, with this field indicating the start of each sub-array
	pub item_offset: Option<Offsets<i32>>,

	pub fod_platform: Option<FodPlatform>,
	pub fod_platform_offset: Option<Offsets<i32>>,

	pub dreamland_whispy: Option<DreamlandWhispy>,
	pub dreamland_whispy_offset: Option<Offsets<i32>>,

	pub stadium_transformation: Option<StadiumTransformation>,
	pub stadium_transformation_offset: Option<Offsets<i32>>,
}

impl Frame {
	pub fn with_capacity(capacity: usize, version: Version, ports: &[PortOccupancy]) -> Self {
		Self {
			id: MutablePrimitiveArray::<i32>::with_capacity(capacity),
			ports: ports
				.iter()
				.map(|p| PortData::with_capacity(capacity, version, *p))
				.collect(),
			start: version
				.gte(2, 2)
				.then(|| Start::with_capacity(capacity, version)),
			end: version
				.gte(3, 0)
				.then(|| End::with_capacity(capacity, version)),
			item: version.gte(3, 0).then(|| Item::with_capacity(0, version)),
			item_offset: version
				.gte(3, 0)
				.then(|| Offsets::<i32>::with_capacity(capacity)),
			fod_platform: version
				.gte(3, 18)
				.then(|| FodPlatform::with_capacity(0, version)),
			fod_platform_offset: version
				.gte(3, 18)
				.then(|| Offsets::<i32>::with_capacity(capacity)),
			dreamland_whispy: version
				.gte(3, 18)
				.then(|| DreamlandWhispy::with_capacity(0, version)),
			dreamland_whispy_offset: version
				.gte(3, 18)
				.then(|| Offsets::<i32>::with_capacity(capacity)),
			stadium_transformation: version
				.gte(3, 18)
				.then(|| StadiumTransformation::with_capacity(0, version)),
			stadium_transformation_offset: version
				.gte(3, 18)
				.then(|| Offsets::<i32>::with_capacity(capacity)),
		}
	}

	pub fn len(&self) -> usize {
		self.id.len()
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Frame {
		transpose::Frame {
			id: self.id.values()[i],
			ports: self
				.ports
				.iter()
				.map(|p| p.transpose_one(i, version))
				.collect(),
			start: version
				.gte(2, 2)
				.then(|| self.start.as_ref().unwrap().transpose_one(i, version)),
			end: version
				.gte(3, 0)
				.then(|| self.end.as_ref().unwrap().transpose_one(i, version)),
			items: version.gte(3, 0).then(|| {
				let (start, end) = self.item_offset.as_ref().unwrap().start_end(i);
				(start..end)
					.map(|i| self.item.as_ref().unwrap().transpose_one(i, version))
					.collect()
			}),
			fod_platforms: version.gte(3, 18).then(|| {
				let (start, end) = self.fod_platform_offset.as_ref().unwrap().start_end(i);
				(start..end)
					.map(|i| {
						self.fod_platform
							.as_ref()
							.unwrap()
							.transpose_one(i, version)
					})
					.collect()
			}),
			dreamland_whispys: version.gte(3, 18).then(|| {
				let (start, end) = self.dreamland_whispy_offset.as_ref().unwrap().start_end(i);
				(start..end)
					.map(|i| {
						self.dreamland_whispy
							.as_ref()
							.unwrap()
							.transpose_one(i, version)
					})
					.collect()
			}),
			stadium_transformations: version.gte(3, 18).then(|| {
				let (start, end) = self
					.stadium_transformation_offset
					.as_ref()
					.unwrap()
					.start_end(i);
				(start..end)
					.map(|i| {
						self.stadium_transformation
							.as_ref()
							.unwrap()
							.transpose_one(i, version)
					})
					.collect()
			}),
		}
	}
}

/// This event only occurs on Dreamland 64, and is sent whenever Whispy changes blow directions.

pub struct DreamlandWhispy {
	/// Which direction Whispy is blowing (0 = None, 1 = Left, 2 = Right)
	pub direction: MutablePrimitiveArray<u8>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl DreamlandWhispy {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			direction: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.direction.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.direction.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.direction.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::DreamlandWhispy {
		transpose::DreamlandWhispy {
			direction: self.direction.values()[i],
		}
	}
}

/// Information about the end of the game.

pub struct End {
	/// *Added: v3.7* Index of the latest frame which is guaranteed not to happen again (rollback)
	pub latest_finalized_frame: Option<MutablePrimitiveArray<i32>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl End {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			latest_finalized_frame: version
				.gte(3, 7)
				.then(|| MutablePrimitiveArray::<i32>::with_capacity(capacity)),
			validity: version
				.lt(3, 7)
				.then(|| MutableBitmap::with_capacity(capacity)),
		}
	}

	pub fn len(&self) -> usize {
		self.validity
			.as_ref()
			.map(|v| v.len())
			.unwrap_or_else(|| self.latest_finalized_frame.as_ref().unwrap().len())
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		if version.gte(3, 7) {
			self.latest_finalized_frame.as_mut().unwrap().push_null()
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		if version.gte(3, 7) {
			r.read_i32::<BE>()
				.map(|x| self.latest_finalized_frame.as_mut().unwrap().push(Some(x)))?
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::End {
		transpose::End {
			latest_finalized_frame: self.latest_finalized_frame.as_ref().map(|x| x.values()[i]),
		}
	}
}

/// This event only occurs on Fountain of Dreams, and is sent for each change in platform height. If both platforms are moving, there will be two events per frame.

pub struct FodPlatform {
	/// Which platform has moved. (0 = Right, 1 = Left)
	pub platform: MutablePrimitiveArray<u8>,
	/// The platform's new height
	pub height: MutablePrimitiveArray<f32>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl FodPlatform {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			platform: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			height: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.platform.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.platform.push_null();
		self.height.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.platform.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.height.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::FodPlatform {
		transpose::FodPlatform {
			platform: self.platform.values()[i],
			height: self.height.values()[i],
		}
	}
}

/// An active item (includes projectiles).

pub struct Item {
	/// Item type
	pub r#type: MutablePrimitiveArray<u16>,
	/// Item’s action state
	pub state: MutablePrimitiveArray<u8>,
	/// Direction item is facing
	pub direction: MutablePrimitiveArray<f32>,
	/// Item’s velocity
	pub velocity: Velocity,
	/// Item’s position
	pub position: Position,
	/// Amount of damage item has taken
	pub damage: MutablePrimitiveArray<u16>,
	/// Frames remaining until item expires
	pub timer: MutablePrimitiveArray<f32>,
	/// Unique, serial ID per item spawned
	pub id: MutablePrimitiveArray<u32>,
	/// *Added: v3.2* Miscellaneous item state
	pub misc: Option<ItemMisc>,
	/// *Added: v3.6* Port that owns the item (-1 when unowned)
	pub owner: Option<MutablePrimitiveArray<i8>>,
	/// *Added: v3.16* Inherited instance ID of the owner (0 when unowned)
	pub instance_id: Option<MutablePrimitiveArray<u16>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Item {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			r#type: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			velocity: Velocity::with_capacity(capacity, version),
			position: Position::with_capacity(capacity, version),
			damage: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			timer: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			id: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			misc: version
				.gte(3, 2)
				.then(|| ItemMisc::with_capacity(capacity, version)),
			owner: version
				.gte(3, 6)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			instance_id: version
				.gte(3, 16)
				.then(|| MutablePrimitiveArray::<u16>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.r#type.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.r#type.push_null();
		self.state.push_null();
		self.direction.push_null();
		self.velocity.push_null(version);
		self.position.push_null(version);
		self.damage.push_null();
		self.timer.push_null();
		self.id.push_null();
		if version.gte(3, 2) {
			self.misc.as_mut().unwrap().push_null(version);
			if version.gte(3, 6) {
				self.owner.as_mut().unwrap().push_null();
				if version.gte(3, 16) {
					self.instance_id.as_mut().unwrap().push_null()
				}
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u16::<BE>().map(|x| self.r#type.push(Some(x)))?;
		r.read_u8().map(|x| self.state.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		self.velocity.read_push(r, version)?;
		self.position.read_push(r, version)?;
		r.read_u16::<BE>().map(|x| self.damage.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.timer.push(Some(x)))?;
		r.read_u32::<BE>().map(|x| self.id.push(Some(x)))?;
		if version.gte(3, 2) {
			self.misc.as_mut().unwrap().read_push(r, version)?;
			if version.gte(3, 6) {
				r.read_i8()
					.map(|x| self.owner.as_mut().unwrap().push(Some(x)))?;
				if version.gte(3, 16) {
					r.read_u16::<BE>()
						.map(|x| self.instance_id.as_mut().unwrap().push(Some(x)))?
				}
			}
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Item {
		transpose::Item {
			r#type: self.r#type.values()[i],
			state: self.state.values()[i],
			direction: self.direction.values()[i],
			velocity: self.velocity.transpose_one(i, version),
			position: self.position.transpose_one(i, version),
			damage: self.damage.values()[i],
			timer: self.timer.values()[i],
			id: self.id.values()[i],
			misc: self.misc.as_ref().map(|x| x.transpose_one(i, version)),
			owner: self.owner.as_ref().map(|x| x.values()[i]),
			instance_id: self.instance_id.as_ref().map(|x| x.values()[i]),
		}
	}
}

/// Miscellaneous item state.

pub struct ItemMisc(
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
);

impl ItemMisc {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self(
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
		)
	}

	pub fn len(&self) -> usize {
		self.0.len()
	}

	pub fn push_null(&mut self, version: Version) {
		self.0.push_null();
		self.1.push_null();
		self.2.push_null();
		self.3.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.0.push(Some(x)))?;
		r.read_u8().map(|x| self.1.push(Some(x)))?;
		r.read_u8().map(|x| self.2.push(Some(x)))?;
		r.read_u8().map(|x| self.3.push(Some(x)))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::ItemMisc {
		transpose::ItemMisc(
			self.0.values()[i],
			self.1.values()[i],
			self.2.values()[i],
			self.3.values()[i],
		)
	}
}

/// 2D position.

pub struct Position {
	pub x: MutablePrimitiveArray<f32>,
	pub y: MutablePrimitiveArray<f32>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Position {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.x.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.x.push_null();
		self.y.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.y.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Position {
		transpose::Position {
			x: self.x.values()[i],
			y: self.y.values()[i],
		}
	}
}

/// Post-frame update data, for making decisions about game states (such as computing stats).
///
/// Information is collected at the end of collision detection, which is the last consideration of the game engine.

pub struct Post {
	/// In-game character (can only change for Zelda/Sheik)
	pub character: MutablePrimitiveArray<u8>,
	/// Character’s action state
	pub state: MutablePrimitiveArray<u16>,
	/// Character’s position
	pub position: Position,
	/// Direction the character is facing
	pub direction: MutablePrimitiveArray<f32>,
	/// Damage taken (percent)
	pub percent: MutablePrimitiveArray<f32>,
	/// Size/health of shield
	pub shield: MutablePrimitiveArray<f32>,
	/// Last attack ID that this character landed
	pub last_attack_landed: MutablePrimitiveArray<u8>,
	/// Combo count (as defined by the game)
	pub combo_count: MutablePrimitiveArray<u8>,
	/// Port that last hit this player. Bugged in Melee: will be set to `6` in certain situations
	pub last_hit_by: MutablePrimitiveArray<u8>,
	/// Number of stocks remaining
	pub stocks: MutablePrimitiveArray<u8>,
	/// *Added: v0.2* Number of frames action state has been active. Can have a fractional component
	pub state_age: Option<MutablePrimitiveArray<f32>>,
	/// *Added: v2.0* State flags
	pub state_flags: Option<StateFlags>,
	/// *Added: v2.0* Used for different things. While in hitstun, contains hitstun frames remaining
	pub misc_as: Option<MutablePrimitiveArray<f32>>,
	/// *Added: v2.0* Is the character airborne?
	pub airborne: Option<MutablePrimitiveArray<u8>>,
	/// *Added: v2.0* Ground ID the character last touched
	pub ground: Option<MutablePrimitiveArray<u16>>,
	/// *Added: v2.0* Number of jumps remaining
	pub jumps: Option<MutablePrimitiveArray<u8>>,
	/// *Added: v2.0* L-cancel status (0 = none, 1 = successful, 2 = unsuccessful)
	pub l_cancel: Option<MutablePrimitiveArray<u8>>,
	/// *Added: v2.1* Hurtbox state (0 = vulnerable, 1 = invulnerable, 2 = intangible)
	pub hurtbox_state: Option<MutablePrimitiveArray<u8>>,
	/// *Added: v3.5* Self-induced and knockback velocities
	pub velocities: Option<Velocities>,
	/// *Added: v3.8* Hitlag frames remaining
	pub hitlag: Option<MutablePrimitiveArray<f32>>,
	/// *Added: v3.11* Animation the character is in
	pub animation_index: Option<MutablePrimitiveArray<u32>>,
	/// *Added: v3.16* Instance ID of the player/item that last hit this player
	pub last_hit_by_instance: Option<MutablePrimitiveArray<u16>>,
	/// *Added: v3.16* Unique, serial ID for each new action state across all characters. Resets to 0 on death
	pub instance_id: Option<MutablePrimitiveArray<u16>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Post {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			character: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			position: Position::with_capacity(capacity, version),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			percent: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			shield: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			last_attack_landed: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			combo_count: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			last_hit_by: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			stocks: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			state_age: version
				.gte(0, 2)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			state_flags: version
				.gte(2, 0)
				.then(|| StateFlags::with_capacity(capacity, version)),
			misc_as: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			airborne: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			ground: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u16>::with_capacity(capacity)),
			jumps: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			l_cancel: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			hurtbox_state: version
				.gte(2, 1)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			velocities: version
				.gte(3, 5)
				.then(|| Velocities::with_capacity(capacity, version)),
			hitlag: version
				.gte(3, 8)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			animation_index: version
				.gte(3, 11)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
			last_hit_by_instance: version
				.gte(3, 16)
				.then(|| MutablePrimitiveArray::<u16>::with_capacity(capacity)),
			instance_id: version
				.gte(3, 16)
				.then(|| MutablePrimitiveArray::<u16>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.character.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.character.push_null();
		self.state.push_null();
		self.position.push_null(version);
		self.direction.push_null();
		self.percent.push_null();
		self.shield.push_null();
		self.last_attack_landed.push_null();
		self.combo_count.push_null();
		self.last_hit_by.push_null();
		self.stocks.push_null();
		if version.gte(0, 2) {
			self.state_age.as_mut().unwrap().push_null();
			if version.gte(2, 0) {
				self.state_flags.as_mut().unwrap().push_null(version);
				self.misc_as.as_mut().unwrap().push_null();
				self.airborne.as_mut().unwrap().push_null();
				self.ground.as_mut().unwrap().push_null();
				self.jumps.as_mut().unwrap().push_null();
				self.l_cancel.as_mut().unwrap().push_null();
				if version.gte(2, 1) {
					self.hurtbox_state.as_mut().unwrap().push_null();
					if version.gte(3, 5) {
						self.velocities.as_mut().unwrap().push_null(version);
						if version.gte(3, 8) {
							self.hitlag.as_mut().unwrap().push_null();
							if version.gte(3, 11) {
								self.animation_index.as_mut().unwrap().push_null();
								if version.gte(3, 16) {
									self.last_hit_by_instance.as_mut().unwrap().push_null();
									self.instance_id.as_mut().unwrap().push_null()
								}
							}
						}
					}
				}
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.character.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.state.push(Some(x)))?;
		self.position.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.percent.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.shield.push(Some(x)))?;
		r.read_u8().map(|x| self.last_attack_landed.push(Some(x)))?;
		r.read_u8().map(|x| self.combo_count.push(Some(x)))?;
		r.read_u8().map(|x| self.last_hit_by.push(Some(x)))?;
		r.read_u8().map(|x| self.stocks.push(Some(x)))?;
		if version.gte(0, 2) {
			r.read_f32::<BE>()
				.map(|x| self.state_age.as_mut().unwrap().push(Some(x)))?;
			if version.gte(2, 0) {
				self.state_flags.as_mut().unwrap().read_push(r, version)?;
				r.read_f32::<BE>()
					.map(|x| self.misc_as.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.airborne.as_mut().unwrap().push(Some(x)))?;
				r.read_u16::<BE>()
					.map(|x| self.ground.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.jumps.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.l_cancel.as_mut().unwrap().push(Some(x)))?;
				if version.gte(2, 1) {
					r.read_u8()
						.map(|x| self.hurtbox_state.as_mut().unwrap().push(Some(x)))?;
					if version.gte(3, 5) {
						self.velocities.as_mut().unwrap().read_push(r, version)?;
						if version.gte(3, 8) {
							r.read_f32::<BE>()
								.map(|x| self.hitlag.as_mut().unwrap().push(Some(x)))?;
							if version.gte(3, 11) {
								r.read_u32::<BE>().map(|x| {
									self.animation_index.as_mut().unwrap().push(Some(x))
								})?;
								if version.gte(3, 16) {
									r.read_u16::<BE>().map(|x| {
										self.last_hit_by_instance.as_mut().unwrap().push(Some(x))
									})?;
									r.read_u16::<BE>()
										.map(|x| self.instance_id.as_mut().unwrap().push(Some(x)))?
								}
							}
						}
					}
				}
			}
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Post {
		transpose::Post {
			character: self.character.values()[i],
			state: self.state.values()[i],
			position: self.position.transpose_one(i, version),
			direction: self.direction.values()[i],
			percent: self.percent.values()[i],
			shield: self.shield.values()[i],
			last_attack_landed: self.last_attack_landed.values()[i],
			combo_count: self.combo_count.values()[i],
			last_hit_by: self.last_hit_by.values()[i],
			stocks: self.stocks.values()[i],
			state_age: self.state_age.as_ref().map(|x| x.values()[i]),
			state_flags: self
				.state_flags
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			misc_as: self.misc_as.as_ref().map(|x| x.values()[i]),
			airborne: self.airborne.as_ref().map(|x| x.values()[i]),
			ground: self.ground.as_ref().map(|x| x.values()[i]),
			jumps: self.jumps.as_ref().map(|x| x.values()[i]),
			l_cancel: self.l_cancel.as_ref().map(|x| x.values()[i]),
			hurtbox_state: self.hurtbox_state.as_ref().map(|x| x.values()[i]),
			velocities: self
				.velocities
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			hitlag: self.hitlag.as_ref().map(|x| x.values()[i]),
			animation_index: self.animation_index.as_ref().map(|x| x.values()[i]),
			last_hit_by_instance: self.last_hit_by_instance.as_ref().map(|x| x.values()[i]),
			instance_id: self.instance_id.as_ref().map(|x| x.values()[i]),
		}
	}
}

/// Pre-frame update data, required to reconstruct a replay.
///
/// Information is collected right before controller inputs are used to figure out the character’s next action.

pub struct Pre {
	/// Random seed
	pub random_seed: MutablePrimitiveArray<u32>,
	/// Character’s action state
	pub state: MutablePrimitiveArray<u16>,
	/// Character’s position
	pub position: Position,
	/// Direction the character is facing
	pub direction: MutablePrimitiveArray<f32>,
	/// Processed analog joystick position
	pub joystick: Position,
	/// Processed analog c-stick position
	pub cstick: Position,
	/// Processed analog trigger position
	pub triggers: MutablePrimitiveArray<f32>,
	/// Processed button-state bitmask
	pub buttons: MutablePrimitiveArray<u32>,
	/// Physical button-state bitmask
	pub buttons_physical: MutablePrimitiveArray<u16>,
	/// Physical analog trigger positions (useful for IPM)
	pub triggers_physical: TriggersPhysical,
	/// *Added: v1.2* Raw joystick x-position
	pub raw_analog_x: Option<MutablePrimitiveArray<i8>>,
	/// *Added: v1.4* Damage taken (percent)
	pub percent: Option<MutablePrimitiveArray<f32>>,
	/// *Added: v3.15* Raw joystick y-position
	pub raw_analog_y: Option<MutablePrimitiveArray<i8>>,
	/// *Added: v3.17* Raw c-stick x-position
	pub raw_analog_cstick_x: Option<MutablePrimitiveArray<i8>>,
	/// *Added: v3.17* Raw c-stick y-position
	pub raw_analog_cstick_y: Option<MutablePrimitiveArray<i8>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Pre {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			random_seed: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			position: Position::with_capacity(capacity, version),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			joystick: Position::with_capacity(capacity, version),
			cstick: Position::with_capacity(capacity, version),
			triggers: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			buttons: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			buttons_physical: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			triggers_physical: TriggersPhysical::with_capacity(capacity, version),
			raw_analog_x: version
				.gte(1, 2)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			percent: version
				.gte(1, 4)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			raw_analog_y: version
				.gte(3, 15)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			raw_analog_cstick_x: version
				.gte(3, 17)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			raw_analog_cstick_y: version
				.gte(3, 17)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.random_seed.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.random_seed.push_null();
		self.state.push_null();
		self.position.push_null(version);
		self.direction.push_null();
		self.joystick.push_null(version);
		self.cstick.push_null(version);
		self.triggers.push_null();
		self.buttons.push_null();
		self.buttons_physical.push_null();
		self.triggers_physical.push_null(version);
		if version.gte(1, 2) {
			self.raw_analog_x.as_mut().unwrap().push_null();
			if version.gte(1, 4) {
				self.percent.as_mut().unwrap().push_null();
				if version.gte(3, 15) {
					self.raw_analog_y.as_mut().unwrap().push_null();
					if version.gte(3, 17) {
						self.raw_analog_cstick_x.as_mut().unwrap().push_null();
						self.raw_analog_cstick_y.as_mut().unwrap().push_null()
					}
				}
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u32::<BE>().map(|x| self.random_seed.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.state.push(Some(x)))?;
		self.position.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		self.joystick.read_push(r, version)?;
		self.cstick.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.triggers.push(Some(x)))?;
		r.read_u32::<BE>().map(|x| self.buttons.push(Some(x)))?;
		r.read_u16::<BE>()
			.map(|x| self.buttons_physical.push(Some(x)))?;
		self.triggers_physical.read_push(r, version)?;
		if version.gte(1, 2) {
			r.read_i8()
				.map(|x| self.raw_analog_x.as_mut().unwrap().push(Some(x)))?;
			if version.gte(1, 4) {
				r.read_f32::<BE>()
					.map(|x| self.percent.as_mut().unwrap().push(Some(x)))?;
				if version.gte(3, 15) {
					r.read_i8()
						.map(|x| self.raw_analog_y.as_mut().unwrap().push(Some(x)))?;
					if version.gte(3, 17) {
						r.read_i8()
							.map(|x| self.raw_analog_cstick_x.as_mut().unwrap().push(Some(x)))?;
						r.read_i8()
							.map(|x| self.raw_analog_cstick_y.as_mut().unwrap().push(Some(x)))?
					}
				}
			}
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Pre {
		transpose::Pre {
			random_seed: self.random_seed.values()[i],
			state: self.state.values()[i],
			position: self.position.transpose_one(i, version),
			direction: self.direction.values()[i],
			joystick: self.joystick.transpose_one(i, version),
			cstick: self.cstick.transpose_one(i, version),
			triggers: self.triggers.values()[i],
			buttons: self.buttons.values()[i],
			buttons_physical: self.buttons_physical.values()[i],
			triggers_physical: self.triggers_physical.transpose_one(i, version),
			raw_analog_x: self.raw_analog_x.as_ref().map(|x| x.values()[i]),
			percent: self.percent.as_ref().map(|x| x.values()[i]),
			raw_analog_y: self.raw_analog_y.as_ref().map(|x| x.values()[i]),
			raw_analog_cstick_x: self.raw_analog_cstick_x.as_ref().map(|x| x.values()[i]),
			raw_analog_cstick_y: self.raw_analog_cstick_y.as_ref().map(|x| x.values()[i]),
		}
	}
}

/// This event only occurs on Pokemon Stadium, and is sent whenever the transformation event or transformation type changes.

pub struct StadiumTransformation {
	/// The subevent for each transformation. (2 = Initialize, 3 = On monitor, 4 = Previous transformation receding, 5 = New transformation rising, 6 = Finalize, 0 = Finished)
	pub event: MutablePrimitiveArray<u16>,
	/// The current or upcoming transformation. (3 = Fire, 4 = Grass, 5 = Normal, 6 = Rock, 9 = Water)
	pub r#type: MutablePrimitiveArray<u16>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl StadiumTransformation {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			event: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			r#type: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.event.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.event.push_null();
		self.r#type.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u16::<BE>().map(|x| self.event.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.r#type.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::StadiumTransformation {
		transpose::StadiumTransformation {
			event: self.event.values()[i],
			r#type: self.r#type.values()[i],
		}
	}
}

/// Initialization data such as game mode, settings, characters & stage.

pub struct Start {
	/// Random seed
	pub random_seed: MutablePrimitiveArray<u32>,
	/// *Added: v3.10* Scene frame counter. Starts at 0, and increments every frame (even when paused)
	pub scene_frame_counter: Option<MutablePrimitiveArray<u32>>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Start {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			random_seed: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			scene_frame_counter: version
				.gte(3, 10)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.random_seed.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.random_seed.push_null();
		if version.gte(3, 10) {
			self.scene_frame_counter.as_mut().unwrap().push_null()
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u32::<BE>().map(|x| self.random_seed.push(Some(x)))?;
		if version.gte(3, 10) {
			r.read_u32::<BE>()
				.map(|x| self.scene_frame_counter.as_mut().unwrap().push(Some(x)))?
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Start {
		transpose::Start {
			random_seed: self.random_seed.values()[i],
			scene_frame_counter: self.scene_frame_counter.as_ref().map(|x| x.values()[i]),
		}
	}
}

/// Miscellaneous state flags.

pub struct StateFlags(
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
);

impl StateFlags {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self(
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
		)
	}

	pub fn len(&self) -> usize {
		self.0.len()
	}

	pub fn push_null(&mut self, version: Version) {
		self.0.push_null();
		self.1.push_null();
		self.2.push_null();
		self.3.push_null();
		self.4.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.0.push(Some(x)))?;
		r.read_u8().map(|x| self.1.push(Some(x)))?;
		r.read_u8().map(|x| self.2.push(Some(x)))?;
		r.read_u8().map(|x| self.3.push(Some(x)))?;
		r.read_u8().map(|x| self.4.push(Some(x)))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::StateFlags {
		transpose::StateFlags(
			self.0.values()[i],
			self.1.values()[i],
			self.2.values()[i],
			self.3.values()[i],
			self.4.values()[i],
		)
	}
}

/// Trigger state.

pub struct TriggersPhysical {
	pub l: MutablePrimitiveArray<f32>,
	pub r: MutablePrimitiveArray<f32>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl TriggersPhysical {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			l: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			r: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.l.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.l.push_null();
		self.r.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.l.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.r.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::TriggersPhysical {
		transpose::TriggersPhysical {
			l: self.l.values()[i],
			r: self.r.values()[i],
		}
	}
}

/// Self-induced and knockback velocities.

pub struct Velocities {
	/// Self-induced x-velocity (airborne)
	pub self_x_air: MutablePrimitiveArray<f32>,
	/// Self-induced y-velocity
	pub self_y: MutablePrimitiveArray<f32>,
	/// Knockback-induced x-velocity
	pub knockback_x: MutablePrimitiveArray<f32>,
	/// Knockback-induced y-velocity
	pub knockback_y: MutablePrimitiveArray<f32>,
	/// Self-induced x-velocity (grounded)
	pub self_x_ground: MutablePrimitiveArray<f32>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Velocities {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			self_x_air: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			self_y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			knockback_x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			knockback_y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			self_x_ground: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.self_x_air.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.self_x_air.push_null();
		self.self_y.push_null();
		self.knockback_x.push_null();
		self.knockback_y.push_null();
		self.self_x_ground.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.self_x_air.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.self_y.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.knockback_x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.knockback_y.push(Some(x)))?;
		r.read_f32::<BE>()
			.map(|x| self.self_x_ground.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Velocities {
		transpose::Velocities {
			self_x_air: self.self_x_air.values()[i],
			self_y: self.self_y.values()[i],
			knockback_x: self.knockback_x.values()[i],
			knockback_y: self.knockback_y.values()[i],
			self_x_ground: self.self_x_ground.values()[i],
		}
	}
}

/// 2D velocity.

pub struct Velocity {
	pub x: MutablePrimitiveArray<f32>,
	pub y: MutablePrimitiveArray<f32>,
	/// Indicates which indexes are valid (`None` means "all valid"). Invalid indexes can occur on frames where a character is absent (ICs or 2v2 games)
	pub validity: Option<MutableBitmap>,
}

impl Velocity {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.x.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.x.push_null();
		self.y.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.y.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Velocity {
		transpose::Velocity {
			x: self.x.values()[i],
			y: self.y.values()[i],
		}
	}
}
